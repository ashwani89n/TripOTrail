const nodemailer = require('nodemailer');
const puppeteer = require('puppeteer');
const pool = require('../database/db');

const sendItinerary = async (req, res) => {
  const { email } = req.body;
  const { tripId } = req.params;

  try {
    const numericTripId = parseInt(tripId, 10);
    if (!numericTripId || isNaN(numericTripId)) {
      return res.status(400).json({ message: 'Invalid trip ID.' });
    }

    const tripMetaResult = await pool.query(
      `SELECT title, start_date, end_date FROM trips WHERE trip_id = $1`,
      [numericTripId]
    );
    if (tripMetaResult.rowCount === 0) {
      return res.status(404).json({ message: "Trip not found." });
    }
    const { trip_name, start_date, end_date } = tripMetaResult.rows[0];

    const destinationsResult = await pool.query(
      `SELECT destination_id, name, category, cost, duration, travel_time, day_date, week_day, order_index
       FROM destinations
       WHERE trip_id = $1
       ORDER BY day_date ASC, order_index ASC`,
      [numericTripId]
    );

    const timelineMap = new Map();
    for (let dest of destinationsResult.rows) {
      const dayKey = dest.day_date.toISOString();
      if (!timelineMap.has(dayKey)) {
        timelineMap.set(dayKey, {
          dayDate: dest.day_date,
          weekDay: dest.week_day,
          selected_spots: [],
        });
      }
      timelineMap.get(dayKey).selected_spots.push({
        name: dest.name,
        category: dest.category,
        cost: dest.cost,
        duration: dest.duration || {},
        travelTime: dest.travel_time,
        order_index: dest.order_index,
      });
    }
    const timeline = Array.from(timelineMap.values()).sort(
      (a, b) => new Date(a.dayDate) - new Date(b.dayDate)
    );

    const htmlContent = buildHTML(trip_name, start_date, end_date, timeline);

    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.setContent(htmlContent, { waitUntil: 'networkidle0' });
    const pdfBuffer = await page.pdf({ format: 'A4', printBackground: true });
    await browser.close();

    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS,
      },
    });

    await transporter.sendMail({
      from: process.env.EMAIL_USER,
      to: email,
      subject: `Your Itinerary for ${trip_name}`,
      text: `Attached is your itinerary for your trip to ${trip_name}.`,
      attachments: [
        {
          filename: `${trip_name}_itinerary.pdf`,
          content: pdfBuffer,
        },
      ],
    });

    res.status(200).json({ message: 'Itinerary PDF sent successfully!' });
  } catch (error) {
    console.error('Email Itinerary Error:', error.message);
    res.status(500).json({ message: 'Failed to send itinerary email.' });
  }
};

const buildHTML = (tripName, start, end, itinerary) => {
  let html = `
    <html><head><style>
      body { font-family: Arial, sans-serif; padding: 20px; color: #333; }
      h2 { color: #1a73e8; }
      h3 { margin-top: 20px; }
      ul { list-style-type: none; padding-left: 0; }
      li { margin: 6px 0; }
    </style></head><body>
    <h2>ğŸŒ Itinerary for ${tripName}</h2>
    <p><strong>Trip Dates:</strong> ${start} to ${end}</p>
    <hr />
  `;

  itinerary.forEach((day, idx) => {
    html += `<h3>ğŸ—“ï¸ Day ${idx + 1} - ${new Date(day.dayDate).toDateString()}</h3><ul>`;
    day.selected_spots.forEach((spot) => {
      html += `<li>ğŸ“ ${spot.name}${spot.cost ? ` - â‚¹${spot.cost}` : ''}</li>`;
    });
    html += `</ul>`;
  });

  html += `<hr/><p style="font-size: 12px; color: #999;">Generated by MyTrip Planner ğŸŒ´</p></body></html>`;
  return html;
};

module.exports = { sendItinerary };
